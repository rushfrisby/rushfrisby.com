<!doctype html>
<html lang="en">
    <head>
        <title>Rush Frisby</title>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="/css/bootstrap.min.css" />
        <link rel="stylesheet" href="/css/site.css" />
        <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
        <link rel="manifest" href="/site.webmanifest" />
    </head>
    <body>
        <div class="container-fluid p-0" id="header">
            <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
                <div class="container">
                    <a class="navbar-brand" href="/">Rush Frisby</a>
                    <button class="navbar-toggler" type="button" onclick="document.getElementById('navbar-toggle').checked = !document.getElementById('navbar-toggle').checked; return false;">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <input type="checkbox" id="navbar-toggle" style="display: none;">
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item">
                                <a class="nav-link" href="/">Home</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="/about">About</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="/keyboards">Keyboards</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="/tags">Tags</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="/archive">Archive</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
            
        <div class="container">
            <div class="row" id="main">
                    <div class="col-md-9">


<article>
    <h2>Authly July 2020 Update</h2>
    <time datetime="7/4/2020 6:24:53 PM +00:00">Published on Sat, 04 Jul 2020 18:24:53 GMT</time>
    <div class="content">
        <p>Development on Authly is going well. My first task was setting up the architecture and the Azure resources I needed. When I first created the solution I had brought in Identity Server 3.x but since then they've come out with 4.0, so I upgraded to that a few days ago. Doing so immediately affected what I was working on because the persisted grant models changed. I am in the middle of writing my own storage libraries currently. Grants will be stored both in Redis and SQL Azure: Redis for quick read access and SQL Azure for historical and billing purposes... which brings me to the billing model I've been thinking of.</p>
<p>Most identity services are charging around $2 per active user a month. This cost is based on a <em>constantly</em> active user. If you have a user who logs in once a month they are considered active and you're paying $2 for them. It's essentially free money for the identity service. Conversely, you could have multiple users share the same account only be charged $2 total. Neither case accurately reflects the costs associated for the services rendered.</p>
<p>I am thinking of charging on a per-login or per-token basis. Doing so would reflect actual usage more closely than what other companies are doing. I'm still working on the cost model but it will involve multiple tiers.</p>
<p>One struggle I am having is using a dynamic list of Identity Providers. All usage I've seen expects IdPs to be defined in the app Startup. I'm still digging into this.</p>
<p>I will try to blog about my progress once a month.</p>

    </div>
    <div class="tags">
        Tags: <a href="/tag/authly">authly</a>
    </div>
</article><article>
    <h2>Doin it again</h2>
    <time datetime="6/2/2020 4:12:02 AM +00:00">Published on Tue, 02 Jun 2020 04:12:02 GMT</time>
    <div class="content">
        <p>Like LL Cool J said back in '96; I'm doin it, and doin it, and doin it again!</p>
<p><img src="/img/post/llcoolj_doin_it.jpg" alt="LL Cool J Doin It" /></p>
<p>At the end of 2016 <a href="application-security-and-single-sign-on">I said I was doin it again</a> too, but never did (follow the link in that post to an empty github repo), and I've already learned .NET Core by now. I've also learned Identity Server and have integrated one of my previous attempts at a SSO with IS4. I've learned a lot of other things since then too. My need now is mostly due to freedom. I want to be free of working for someone else, to do what I please, whenever I want. In order to get there I have to start making money on my own. This will allow me to do that.</p>
<p>I know I can compete with the major players in the Identity Management space. I've built this solution so many times already that I can do it in my sleep. I may not be able to beat them on number of features right away but I can beat them on price. The other guys are expensive at $2/active user/month. It's why a lot of companies choose to roll their own instead of use a provider. I'm hoping to change that by charging per-login (and refresh tokens). It will be cheap - like pennies per login cheap. I'm a single developer using my own free time to do this so I can do that. I have some other tricks up my sleeve but this is the plan at it most basic.</p>
<p>As far as the tech I have already started working on it. It's on .NET Core 3.1 using SQL Azure and hosted as an App Service in Azure. I'm also using the latest version of Identity Server for the OpenId Connect and OAuth stuff. It will auth against local users, social media, and other Identity Providers. The solution is mostly about user, client, authN, authZ, and access control management. It's not just a hosted version of Identity Server.</p>
<p>I'm calling in <a href="https://authly.io">Authly</a>. Not 100% sold on the name yet. It could be memorable with some witty tie-ins to the word <em>awfully</em>. We'll see. More to come soon!</p>

    </div>
    <div class="tags">
        Tags: <a href="/tag/sso">sso</a> <a href="/tag/single sign on">single sign on</a> <a href="/tag/security">security</a> <a href="/tag/identity management">identity management</a> <a href="/tag/identity provider">identity provider</a> <a href="/tag/openid">openid</a> <a href="/tag/openId connect">openId connect</a> <a href="/tag/oidc">oidc</a> <a href="/tag/identity server">identity server</a> <a href="/tag/authentication">authentication</a> <a href="/tag/authorization">authorization</a> <a href="/tag/access control">access control</a> <a href="/tag/authly">authly</a>
    </div>
</article><article>
    <h2>InterfaceRpc 2.0</h2>
    <time datetime="10/1/2019 1:29:01 AM +00:00">Published on Tue, 01 Oct 2019 01:29:01 GMT</time>
    <div class="content">
        <p>This past week my Interface RPC library hit version 2.0 and I want to take a minute to go over how I got there.</p>
<p>I used the first version for a few services that my company depends on. It was running in production just fine, for a while. After a couple months I found an issue however. The issue was with how exceptions were handled by my code which in-turn caused an additional exception. The result of this caused threads to hang and eventually starve the system. It was a simple fix and services continued to run fine.</p>
<p>I ran into a second problem a few months later. This one, however, was much more serious and caused a service to hang until restarted. I knew what method was being called to cause it but that's about it. I didn't do much digging other than that because I didn't want to maintain the HttpListener implementation of this library any more. It was a stop-gap for how I really wanted it to work anyways...</p>
<p>Ideally I wanted to host the service on ASP.NET Core and plug into that ecosystem of things, like; depenency injection, configuration, and security.</p>
<p>So that's what I did. Instead of fixing a bug I chucked most of my code, refactored what was left (A LOT), and made a 2.0 I felt a whole lot better about.</p>
<p>I've had 2.0 running in production for months now with no issues. This past week a co-worker tidy'd up one last thing which pushed me over the edge in removing the pre-release moniker and published the official 2.0 nuget package! Let's take a look.</p>
<h2>Service Setup</h2>
<p>This is done during Startup within the <code>Configure</code> method. The RPC service is essentially now middleware in the ASP.NET pipeline.</p>
<pre><code class="language-cs">public void Configure(IApplicationBuilder app)
{
    app.UseRpcService&lt;IDemoService&gt;(options =&gt; {...});
}
</code></pre>
<p>The options you can configure are</p>
<ul>
<li><strong>Prefix</strong> - hosts the service under a virtual subdirectory. This is useful for hosting multiple services in the same app.</li>
<li><strong>AuthorizationScope</strong> - either <code>None</code>, <code>Required</code>, or <code>AdHoc</code> (default). If AdHoc then authorization will only be checked when your method is decorated with <code>AuthorizeAttribute</code>.</li>
<li><strong>ServiceFactory</strong> - a function that returns the instance of the interface. You can grab this from ASP.NET's DI container by calling <code>app.ApplicationServices.GetService&lt;IDemoService&gt;()</code></li>
<li><strong>AuthorizationHandler</strong> - a function that returns true for authorized. See below for an example.</li>
</ul>
<p>Here we are looking for a security token in the Authorization header to determine if a user is authorized to access the service.</p>
<pre><code class="language-cs">options.AuthorizationHandler = (methodName, instance, context) =&gt;
{
    if(!context.Request.Headers.ContainsKey(&quot;Authorization&quot;))
    {
        return false;
    }
    if(!context.Request.Headers.TryGetValue(&quot;Authorization&quot;, out StringValues authHeader))
    {
        return false;
    }
    var bearerCredentials = authHeader.ToString().Split(&quot; &quot;.ToCharArray(), StringSplitOptions.RemoveEmptyEntries)[1];
    var tokenHandler = new JwtSecurityTokenHandler();

    var validationParameters = new TokenValidationParameters
    {
        IssuerSigningKey = _signingCredentialStore.GetSigningCredentialsAsync().GetAwaiter().GetResult().Key,
        ValidAudience = &quot;demo-service&quot;,
        ValidIssuer = &quot;https://sso.domain.com&quot;
    };

    var user = tokenHandler.ValidateToken(bearerCredentials, validationParameters, out SecurityToken securityToken);
    var token = securityToken as JwtSecurityToken;
    return token != null &amp;&amp; token.ValidTo &gt;= DateTime.Now;
};
</code></pre>
<p><code>_signingCredentialStore</code> is defined in the Startup class as <code>private static ISigningCredentialStore _signingCredentialStore;</code> and is set in the <code>ConfigureServices</code> method by calling <code>serviceProvider.GetService&lt;ISigningCredentialStore&gt;()</code></p>
<p><code>IDemoService</code> is also configured in <code>ConfigureServices</code> just like any other implementation would.</p>
<pre><code class="language-cs">services.AddTransient&lt;IDemoService, DemoService&gt;();
</code></pre>
<h2>Creating a Client</h2>
<p>The client code hasn't changed much.</p>
<pre><code class="language-cs">var client = RpcClient&lt;IDemoService&gt;.Create(new RpcClientOptions
{
    BaseAddress = &quot;https://demo.domain.com&quot;,
    SetAuthorizationHeaderAction = () =&gt;
    {
        return new RpcClientAuthorizationHeader
        {
            Credentials = &quot;access token&quot;,
            Type = &quot;Bearer&quot;
        };
    }
});
</code></pre>
<p><code>SetAuthorizationHeaderAction</code> will be called before every request.</p>
<h2>Wrapping Up</h2>
<p>Everything else pretty much works the same as before. The service responds to POST requests where the method name in the URL translates to a method on the interface. Serialization can be any type defined in the <a href="https://www.nuget.org/packages/SerializerDotNet/">SerializerDotNet</a> library (JSON and Protobuf currently).</p>
<p>One thing that is not apparent is that the service and client both handle async methods.</p>
<p>I hope you find this useful and choose to use it for your next project! If you'd like to contribute you can find the source on <a href="https://github.com/rushfrisby/InterfaceRpc">GitHub</a>.</p>

    </div>
    <div class="tags">
        Tags: <a href="/tag/rpc">rpc</a> <a href="/tag/services">services</a> <a href="/tag/aspnet">aspnet</a>
    </div>
</article><article>
    <h2>Interface to RPC Service</h2>
    <time datetime="8/2/2018 6:28:49 AM -04:00">Published on Thu, 02 Aug 2018 10:28:49 GMT</time>
    <div class="content">
        <p>I'm currently working on <a href="https://github.com/rushfrisby/InterfaceRpc">a project to quickly stand up an RPC service</a> based on an interface. It's a .NET Standard library. Here's how it works.</p>
<p>Let's say you have an interface,</p>
<pre><code>public interface IEchoService
{
    string Echo(string echo);
}
</code></pre>
<p>, and you have an implementation that needs to be exposed so that others can call it. I chose HTTP for this.</p>
<p>On the server I use <code>HttpListener</code> to create a web server and listen for requests. When a request comes in the path maps to a method name. For example, if my web server is listening on <code>http://localhost:6000/</code> and a request for <code>http://localhost:6000/Echo</code> comes in - that maps to the <code>Echo</code> method on the interface... then I use reflection to call it on the implementation that was provided.</p>
<p>If <code>Echo</code> didn't map to a method on the interface then a 404 response is returned.</p>
<p>In my library all HTTP requests are POSTs. The content is deserialized based upon the <code>Content-Type</code> header value of the request. I am using another library I created to handle this called <a href="https://github.com/rushfrisby/SerializerDotNet">SerializerDotNet</a>. At the time of writing it supports JSON and Protobuf. The same serializer used for deserialization is also used to return data in the response and the response's <code>Content-Type</code> is the same as the incoming request.</p>
<p>Remember when I said &quot;quickly stand up an RPC service&quot;? This is how quickly it's done...</p>
<pre><code>var svc = new RpcService&lt;IEchoService&gt;(new EchoService());
svc.Start();
</code></pre>
<p>To use this in your own project add <a href="https://www.nuget.org/packages/InterfaceRpc.Service/">InterfaceRpc.Service</a> to your project using NuGet.</p>
<p>There is a file called <code>rpcsettings.json</code> where you can specify additional settings. Currently only the web server prefixes and number of connections.</p>
<p>To create a client it's just as easy...</p>
<pre><code>var client = new RpcClient&lt;IEchoService&gt;.Create(&quot;http://localhost:6000/&quot;);
</code></pre>
<p>To use this in your own project add <a href="https://www.nuget.org/packages/InterfaceRpc.Client/">InterfaceRpc.Client</a> to your project using NuGet.</p>
<p>By default it uses <code>JsonSerializer</code>. There is an optional 2nd argument where you can specify the type of <code>ISerializer</code> (like <code>ProtobufSerializer</code>)</p>
<p>Then you can call any method defined in your interface:</p>
<pre><code>var echoed = client.Echo(&quot;hello&quot;);
</code></pre>
<h4>Limitations</h4>
<p>(stuff I could use help on)</p>
<ul>
<li><p>I punted on handling SSL certs so it only runs over plain HTTP right now. This seems reasonable given that it's common to setup a load balancer or proxy in front of web sites and services.</p>
</li>
<li><p>8 parameters in method signatures - this can expand to more in the future, if needed, but I think once you get this many it's better to create a class with properties for each and use 1 parameter in the signature.</p>
</li>
<li><p>Because of limitations with <code>ValueTuple</code>, text based serialization reads a little funky, but I'm sure Microsoft will fix this in future versions of .NET Standard. In the meantime I'm curious to see what people think about having &quot;Item1&quot;, &quot;Item2&quot;, etc... map to method parameters. There could be some work done to replace these with parameter names but it would add (unnecessary?) overhead.</p>
</li>
<li><p>A good name. Any suggestions?</p>
</li>
<li><p>See the <a href="https://github.com/rushfrisby/InterfaceRpc/issues">issues list on github</a> for more</p>
</li>
</ul>
<h4>Why?</h4>
<p>This will help tremendously in moving off of WCF / .NET Framework and onto .NET Core. WCF clients aren't supported in .NET Core. The good thing about WCF is that it is interface-based, so swapping out a server implementation is relatively easy. Assuming a <code>ChannelFactory</code> was used for the client, it can be replaced even easier.</p>
<p>If you'd like to help in fleshing this idea out more please contribute through the <a href="https://github.com/rushfrisby/InterfaceRpc">github repo</a>!</p>
<table width="100%" style="border:1px solid #c0c0c0;">
<tr>
<td nowrap="nowrap"><a href="https://www.nuget.org/packages/InterfaceRpc.Service/" target="_blank">InterfaceRpc.Service</a></td>
<td width="100%"><a href="https://www.nuget.org/packages/InterfaceRpc.Service/" target="_blank"><img src="https://img.shields.io/nuget/v/InterfaceRpc.Service.svg?style=flat" alt="NuGet Status" style="display:inline;padding:0" /></a></td>
</tr>
<tr>
<td nowrap="nowrap"><a href="https://www.nuget.org/packages/InterfaceRpc.Client/" target="_blank">InterfaceRpc.Client</a></td>
<td width="100%"><a href="https://www.nuget.org/packages/InterfaceRpc.Client/" target="_blank"><img src="https://img.shields.io/nuget/v/InterfaceRpc.Client.svg?style=flat" alt="NuGet Status" style="display:inline;padding:0" /></a></td>
</tr>
</table>

    </div>
    <div class="tags">
        Tags: <a href="/tag/rpc">rpc</a> <a href="/tag/services">services</a>
    </div>
</article><article>
    <h2>Losing Our Memory</h2>
    <time datetime="12/8/2017 4:27:00 PM -05:00">Published on Fri, 08 Dec 2017 21:27:00 GMT</time>
    <div class="content">
        <p>I read <a href="http://www.hanselman.com/blog/WhenDidWeStopCaringAboutMemoryManagement.aspx">this post by Scott Hanselman</a> a while back and agree with him in that memory management in .NET is not a concern for developers. I have not thought directly about any of the items he listed within the last 10 years. I learned low level programming early on but once I moved into higher level languages, memory management became something I thought about less and less. There are three factors that contribute to this: Memory capacity, cost, and management.</p>
<p>Memory capacity took a huge jump in the late 2000s. It became common for run-of-the-mill servers to have 16GB+ of RAM. The amount of memory available now is so excessive that database servers can run entirely in memory. In the unlikely event that memory runs out, the emergence of the cloud and auto-scaling saves us - which brings me to my next point.</p>
<p>Memory costs nothing! It's so cheap that maxing out a server with the most RAM possible is expected. If your server is running in the cloud it's not even worth mentioning &quot;memory&quot;. The cost of cloud servers is cheap and auto-scaling means you're only paying for what you need anyways. If you need more memory the cloud will give it to you automatically and for the most part without you even knowing!</p>
<p>The third reason why, and most specifically for .NET developers, is that the garbage collector does a darn good job of memory management. This was one of the original selling features of the framework! Let the GC handle what it was meant to do and let developers solve the problem at hand.</p>
<p>Recently I've thought a lot memory management. That's because my company develops firmware in C on handheld devices with a low amount of memory. Hardware specs aren't something companies change regularly and we have a good sourcing cost for the chips we get. Let's just say that there is no incentive to add more memory so developers have to make-do with what they've got.</p>
<p>I'm not writing C, so I'm not thinking about memory directly, but I'm writing web services that are consumed by these devices. Here are some things I have to keep in mind during development:</p>
<ul>
<li>The serialization format must be compatible and performant on our device.</li>
<li>The data types returned must be platform agnostic.</li>
<li>The data structures must adhere to a strict contract.</li>
<li>The size of each piece of data could be an issue.</li>
<li>The overall size of requests and responses must be as small as possible.</li>
</ul>
<p>If all of these criteria are met then I have a <em>pretty good</em> chance of the device being able to work well with the service.</p>
<p>As far as the technologies I chose, I went with Protobuf for serialization. It's fast and produces small output. It's supported on all of the systems &amp; languages my company is working with. Both the software and firmware teams can utilize .proto definitions as contracts and generate structures/classes from them. Protobuf isn't a silver bullet though. I still need to be mindful of the data I am working with...</p>
<p>For example, before our device can communicate with the service it must obtain a security token (a <code>string</code>). I found bug in the the way the security token was generated, so I fixed it, and pushed a new version of the service out. Suddenly our devices stopped working! What happened?</p>
<p>It turns out that the token, before my fix, was 1000 characters long. The firmware team allocated 1000 characters for that field in their code. When I made my fix the token generated was 1200 characters long. The device was truncating the string and subsequent requests to the service couldn't be validated because the token wasn't correct. I hadn't given one thought to the size of token value because a <code>string</code> type in .NET can hold a variable length (fairly large) string no problem. On our devices though, that 1000 characters was critical!</p>
<p>In conclusion, I don't expect .NET developers will actively pay attention to memory management. They should keep it in the back of their mind at all times though. It's important to know how the framework you are working with deals with memory. It would be a good investment to dig deep into it when beginning to learn a new framework. Once .NET Core becomes more prevalent I expect memory management will garner some attention, but ultimately it will end up in the state that .NET Framework developers are in now - ignorance.</p>

    </div>
</article>

                </div>
                <div class="col-md-3">
                    <div class="card mb-3">
                        <h5 class="card-header text-white bg-secondary">Hello</h5>
                        <div class="card-body">
                            <p class="center"><img src="/img/rush_headshot_2018_256-min.jpg" title="Rush Frisby" alt="Rush Frisby" width="213" height="213" /></p>
                            <p>Rush is a software architect who loves solving problems. You'll usually find him writing about security concepts and sharing solutions to problems he's faced.</p>
                        </div>
                    </div>
                    <div class="card mb-3">
                        <h5 class="card-header text-white bg-secondary">Recent Posts</h5>
                        <div class="list-group list-group-flush">
                            <div class="list-group">
                                <a href="/authly-july-2020-update" class="list-group-item list-group-item-action">Authly July 2020 Update</a>
                                <a href="/doin-it-again" class="list-group-item list-group-item-action">Doin it again</a>
                                <a href="/interfacerpc-20" class="list-group-item list-group-item-action">InterfaceRpc 2.0</a>
                                <a href="/interface-to-rpc-service" class="list-group-item list-group-item-action">Interface to RPC Service</a>
                                <a href="/losing-our-memory" class="list-group-item list-group-item-action">Losing Our Memory</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row" id="footer">
                <div class="col">
                    <p><a href="https://github.com/rushfrisby/rushfrisby.com" target="_blank">Published to github</a> using a <a href="https://github.com/rushfrisby/RushBlog" target="_blank">blog engine</a> I wrote!</p>
                </div>
            </div>
        </div>
    </body>
</html>
